[1_python]

    일부 운영체제에서는 호환성때문에 python명령어를 사용하면 python2로 접속이 된다. python2는 사용하면 안되며 python3를 사용해야 한다.
    $ python3 

    git을 생성 및 초기화
    $ git init


[2_Django]

    패키지 설치 및 관리를 위해 poetry를 사용한다.(=pip) pip보다 관계관리에 편리하다.
    poetry를 설치한다. (https://python-poetry.org/docs)
    $ curl -sSL https://install.python-poetry.org | python3 -
    그리고 터미널을 죽인 후에 터미널을 다시 열고 poetry를 실행시킨다. (vscode에선 쓰래기통 아이콘을 클릭해서 kill terminal 할 수 있다.)

    가상환경(shell)을 생성하여 shell내에 django를 설치해준다. 컴퓨터 전역에 django를 설치하지 않기위해서다.

    poetry를 설치해준다.
    $ poetry init
        여러 질문형식으로 값을 넣어주면 알아서 설정해준다.
        전부 엔터를 쳐주고 마지막에 no no yes를 넣어준다.(라이센스는 MIT)
    pyproject.toml 파일이 생성되며 설정내용은 구현되어있다.

    poetry를 통해 django를 설치한다.
    $ poetry add django
    poetry.lock이 생성된다. 코드가 실행된 환경에 대한 정보를 담고 있다.
    poetry.toml tool부분에 django내용이 추가된다.
        poetry.lock, poetry.toml 파일을 읽어서 shell이 만들어 진다.

    poetry shell안에서 django를 사용 가능하다.
    poetry shell안으로 들어간다. (django 는 airbnb-clone-backend 폴더 안에 만든 poetry 방울 안에만 설치되어 있다!)
    $ poetry shell   

    django사용가능하여, 명령어를 확인 가능하다.
    $ django-admin

    프로젝트를 실행해준다. 보통은 프로젝트생성하면서 디렉토리도 같이 생성하지만 poetry초기화를 위해서 미리 디렉토리를 생성했다.
    $ django-admin startproject [프로젝트명='config'] .
    프로젝트 폴더와 manage.py 이 생성된다. manage.py 파일이 터미널에서 Django 명령어를 실행한다.
        $ python manage.py [tap]   을 클릭하면 실행가능한 명령어들을 확인 할 수 있다.

    서버를 실행해본다. 
    $ python manage.py runserver
    데이터베이스가 없다면 db.sqlite3 가 생성된다. 
    서버는 실행이되나 migration을 해달라는 경고문이 발생한다.

    ./admin 에 접속을 하면 no such table: django_session 에러가 발생한다. 
    admin 패널을 실행하기 위해서는 admin 유저가 필요하며 admin 유저가 작동하기 위해서는 session이 필요하다.
        이렇게 Django에는 admin패널을 위한 기능이 내장되어 있다.
    해당 session을 생성하기 위해서는 migrate가 필요하다.
    $ python manage.py migrate
    db에 app 데이터가 추가되었다. 마이그래이션 파일은 데이터베이스의 모양을 변형시키는 파이선코드가 들어있다.

    python 서버를 실행시키며 터미널을 하나 더 실행시킨 후 shell안에서 admin user를 생성한다.
    $ python manage.py createsuperuser
    admin user 가 생성되면 로그인이 되며 user리스트에서 추가된것을 확인 가능하다. 데이터 변경에 정적이지 않으며 실시간 동작한다. 
    functional하게 실행된며 유저인증도 쉽게 얻을 수 있다. 유저정보 변경 및 권한 변경도 패널에서 가능하다. awesome!
    비밀번호는 hash화 되어 저장되면 원본 비밀번호는 저장되지 않는다. 유저가 생성된 날짜와 마지막 접속일자도 확인 가능.
    user 패널은 리스트 컬럼명과 filter기능이 기본 구현되어있다.

    라이브러리는 코드에서 해당 라이브러리를 request하여 사용하지만 프레임워크는 프레임워크에서 내 코드를 찾아서 실행한다. 프레임워크가 요구하는 위치에 코드가 있어야 실행이 된다.

    app 내에 시간은 세계시간(UTC)기준으로 표기된다. config>settings.py 변경해준다.
        TIME_ZONE = "UTC"
        >>>TIME_ZONE = "Asia/Seoul"
    언어도 변경해준다.
        LANGUAGE_CODE = "en-us"
        >>>LANGUAGE_CODE = "ko-kr"

    config>url.py 은 url path, 실행될 app을 구현한다.
    settings.py, urls.py 파일명과 구현된 variable은 프레임워크 요건에 충족시켜야 실행된다.

    장고 app 은 어플리케이션의 로직과 데이터를 합쳐서 캡슐화한다.


#### 4. Django Apps

    [2_Django]

        house 엡을 생성한다.
        $ python manage.py startapp houses
            [app]> migrations폴더, __init.py, admin.py, apps.py, models.py, tests.py, views.py 생성된다.
        각 파일에는 구현해야할 코드가 무엇인지 주석이 있다.

        config>settings.py 에 INSTALLED_APPS 리스트에 앱을 추가하여 설치한다.
            "houses.apps.HousesConfig",
        추가를 해주면 설치가 완료되며 django가 해당 app을 인지한다.

        models.py엔 app 에 데이터형태를 구현한다. 구현된 형태를 migration 하면 django 는 database를 만들어준다.
        model을 구현할때 djanog의 models.Model을 overriding한다. 
            CharField : 최대길이값이 필수 (max_length)
            PositiveIntegerField : 양수인 정수값만 받음
            다른 설정 방법 확인은 https://docs.djangoproject.com/en/4.1/ref/models/fields/
            primarykey, unique, verbose_name

        Django 는 커스텀 데이터에 대한 관리 패널을 자동으로 생성해준다. admin.py에 해당 앱 관리에 추가해준다.
            from .models import House
            
            @admin.register(House)  # admin(통제)할 앱을 넣어준다. 여러개 넣을 수 있다.
            class HouseAdmin(admin.ModelAdmin):  # ModelAdmin 은 admin패널이다.
                # admin 패널 화면 구현
                pass
        pass로 overriding 하면 구현된 model을 전부 넣어준다.

        해당 app을 데이터베이스에 알려줘야한다. 데이터베이스에 모델을 생성해준다.
        $ python manage.py makemigrations
            [app]>migrations 폴더에 새로운 db 모델을 설명하는 파일이 생성된다.
        그리고 migrate를 실행하여 데이터베이스의 모양을 update한다.
            __pycache__폴더에 변경된 데이터를 설명하는 파일이 생성된다.

        # 도중에 `db.sqlite3`파일을 지워서 migrate해도 no such table이 뜬다면,
        # $ python manage.py migrate --run-syncdb

        서버를 실행하여 앱 admin패널에서 데이터 검색, 추가, 수정, 삭제가 가능하다. django는 데이터 저장 및 수정에서 데이터 유효검사를 해준다.

        settings.py 에 INSTALLED_APPS 을 SYSTEM_APPS와 CUSTOM_APPS로 분류 적용한다.
            INSTALLED_APPS = SYSTEM_APPS + CUSTOM_APPS
        Django 에서 INSTALLED_APPS 를 찾는다.


    [1_python]

        models.py에 __str__을 구현하여 해당 app 데이터를 불러올때 표시할 값을 정한다.
            def __str__(self):
                return self.name


    [2_Django]
        admin.py에 admin패널 리스트 컬럼과 필터를 적용할 수 있다. string으로 리스트에 추가한다.
            list_display = [
                # 리스트에 표기할 컬럼(variable)
            ]
            list_filter = [
                # 필터에 추가할 variable
            ]
        
        # 예전에 makemigrations 이 없을 때에는 db를 삭제하고 새로 생성했어야했다.

        admin패널에서 검색창을 구현할 수 있다. string으로 리스트에 추가한다.
            search_fields = [
                # 검색할 var
            ]
        리스트에 추가된 variable 내에서 조회가 이뤄진다.
        기본 설정으로는 검색값의 string 이 포함된 전체 컬럼을 조회해온다. 조회될 값을 찾는 방법을 설정할 수 있다.
            [variable]__startswith : 검색값으로 시작하는 값을 조회
            그외의 설정방법은 https://docs.djangoproject.com/en/4.1/ref/contrib/admin/#django.contrib.admin.ModelAdmin.search_fields
            exclude, fields, list_display_links, list_per_page, list_editable, read_only ....
        

#### 5. Users App

    [2_Django]

        Django에는 기본 user관리를 위한 데이터테이블과 admin판넬이 제공된다. 하지만 user 데이터 변경을 위해서는 Django의 user클래스를 inherit하여 overriding을 할 필요가 있다.
        https://docs.djangoproject.com/en/4.1/topics/auth/customizing/#substituting-a-custom-user-model
        데이터 작업이 어느정도 이뤄지고 나서 users app을 변경할려면 작업이 매우 복잡해진다. 프로젝트가 완료되고 런칭되어서 데이터가 쌓이기전에 변경작업을 진행하자.
        ! Django application 을 시작하는 처음부터 user model을 교체하자. 무조건 교체하자. 교체할게 하나도 없더라도 inherit만 구현해놓자 !


    [1_python]   

        vscode내에서 python코드 및 django코드에 노란줄이 그어지며 인식은 하지못한다면 확장프로그램에 pylance를 설치해준다. 
        pylance는 vscode를 위한 python 서버이다. 자동완성 및 import를 도와준다.
        Django가 shell내에 설치되어 vscode에서 인식이 되지 않는다. 
        vscode하단 Select Language Mode에 python을 클릭하면 Select Interpreter 창이 열리며 사용할 Python 환경을 선택해주면된다. 오른쪽 text에 poetry가 있디면 그걸 선택해주면 된다.

        fomatter black을 설치해준다. 확장프로그램 설치로 적용이 되지 않는다면 인터넷에 검색하여 적용하자.
            정 안되면 노마드코더의 #5.0 Introduction 영상이나 댓글 및 Issues를 확인하자.

    
    [2_Django]

        Users 앱을 생성 프로세스 진행힌다(startapp -> settings설치 -> migrate). migration은 오류확인을 위해 나중에 진행한다.
        해당 앱은 Django의 User를 상속받는다.
            from django.contrib.auth.models import AbstractUser

        프로젝트 시스템에 Django의 User를 상속받아 구현하여 사용할 것을 알려줘야한다. config>settings.py에 설정값을 넣어준다. 상단 User Document에 내용이 있다.
            #AUTH
            AUTH_USER_MODEL = '[myapp='users'].[MyUser='User']'
        
        migration시 오류가 발생한다.
            >>> Migration admin.0001_initial is applied before its dependency users.0001_initial on database 'default'.
        기존에 Django User에 생성된 user가 있어서 Django User를 상속받은 user app을 구현할 수가 없다. 
        ! 기존의 db를 삭제 후 다시 migrate를 진행해야한다. db를 삭제하며 migrations폴더 내의 파일중 00XX_XXXX.py파일도 삭제한다. 그외 파일은 삭제하지 않는다.
        전체 migration을 다시 진행한다.
        
        user admin페이지 구현도 Django userAdmin을 상속받아서 하면된다.
            from django.contrib.auth.admin import UserAdmin
        
        User model을 커스텀한다. 기존에 Django Useradmin에 first_name과 last_name을 수정불가하도록 커스텀하였다.
            editable, 
        컬럼을 추가한 후 makemigrations를 진행하면 오류가 발생한다. 
            It is impossible to add a non-nullable field 'is_host' to user without specifying a default. This is because the database needs something to populate existing rows.
            Please select a fix:
            1) Provide a one-off default now (will be set on all existing rows with a null value for this column)
            2) Quit and manually define a default value in models.py.
            Select an option:
        기존에 있는 유저에게 추가된 컬럼에 넣어줄 값이 정해져 있지 않아서 발생한 오류이다. 
        default값을 정의해주든가 null값을 허용하면 된다. default값을 정의해준다.
        migration을 진행한다. 

        User admin페이지에서 User정보 입력페이지에 들어가면 오류가 발생한다.
            'first_name' cannot be specified for User model form as it is a non-editable field. Check fields/fieldsets/exclude attributes of class CustomUserAdmin.
        User model에서 first_name과 last_name을 수정 불가하도록 적용했으나 Django Useradmin페이지에서는 수정하도록 설정되어 있어서 오류가 발생하였다.
        UserAdmin을 상속받은 클래스를 커스텀한다.
            fieldsets: model의 field가 보이는 순서를 설정. 일종의 섹션안에 field를 넣어서 그 섹션에 제목을 붙일 수 있다. 리스트나 튜플로 구성되어야한다.
            fields: model의 field가 보이는 순서를 설정.
            users>admin.py 참조
            UserAdmin의 permission과 Important dates을 복사해와 CustomUserAdmin>fieldsets에 붙여넣기하자.
            더보기. https://docs.djangoproject.com/en/4.1/ref/contrib/admin/#modeladmin-options

        유저 커스텀이 완료되면 room model에서 user Foreignkey를 등록한다. on_delete는 필수값으로 설정한다.
            on_delete = models.SET_NULL: 외래키가 삭제되면 연결되어있는 컬럼은 Null로 적용된다.
                      = models.CASCAGE: 외래키가 삭제되면 연결되어있는 데이터도 같이 삭제된다.
        Foreignkey을 받은 컬럼은 Foreignkey의 ID값을 갖는다.
        추후에 ORM을 사용하여 데이터를 갖고오는 작업을 할 것이다. 매우 간단하게 구현할 수 있다.

        db.sqlite3를 시각화 하기위해서는 sqlite viewer 확장프로그램을 설치하면 된다.